
"""
Lab2-2. Wolfram-Beta OO
support cos, sin, exp
float type degree & factor

Object Oriented
using classes
    WolframBeta
    Terms (has terms_dict)
"""
import traceback
import math


class Terms:
    def __init__(self, equation=None):
        """
        :param equation: str, 문자열로 표현된 함수
                        None 인 경우 terms_dict 를 생성만 함
        """
        # make Terms.terms : dict {key = degree, val = factor}
        # store the equation if not None
        self.terms_dict = dict()
        self.equation = None
        pass

    def __str__(self):
        """
        :return: str equation
        """
        # this function support interface
        # str(Terms) -> string (equation)
        return self.print_equation()

    def __eq__(self, other):
        """
        :param other: Terms
        :return: True when equal, ow False
        """
        # don't modify this function
        if type(other) != Terms:
            return False

        t1 = self.terms_dict
        t2 = other.terms_dict
        eps = 1e-6

        keys = set(t1.keys()).union(t2.keys())
        for k in keys:
            if not math.isclose(t1.get(k, 0), t2.get(k, 0),
                                rel_tol=eps, abs_tol=eps):
                return False
        return True

    @staticmethod
    def print_term(degree, factor):
        """
        :param degree: float, 항의 계수
        :param factor: float, 항의 차수
        :return: str
        """
        # use wolfram_beta's print_term
        return str()

    def print_equation(self):
        """
        :param self: self.terms_dict: dict {key=degree, value=factor}
        :return: str equation
        """
        # use wolfram_beta's print_equation
        return str()

    @staticmethod
    def parse_term(term_str):
        """
        :param term_str: str (a single term <- a part of equation)
        :return: 2-tuple (degree: float/str, factor: float)
        """
        # use wolfram_beta's parse_term
        # now, degree is float
        #             or (cos(x), sin(x), exp(x)
        #      factor is float
        return (0.0, 0.0)

    def parse_equation(self, equation):
        """
        :param equation: str
        :return: None (modify self.terms_dict)
        """
        # update self.terms_dict
        # terms in equation is separated by ' + '
        # use dict.get(key, default)
        self.terms_dict = dict()

    def d_dx_as_terms(self):
        """
        :return: Terms : that result of differential
        """
        # make Terms that result of differential
        dterms = Terms()

        # process each term (degree, factor) in terms
        # use dict.get(key, default)

        return dterms

    def integral_as_terms(self, constant):
        """
        :param constant: float
        :return: Terms : that result of integral
        """
        # make Terms that result of integral
        iterms = Terms()

        # process each term (degree, factor) in terms
        # use dict.get(key, default)

        # don't forget the constant
        return iterms

    def compute_as_terms(self, x):
        """
        :param x: float
        :return: float
        """
        result = 0.0
        # compute the result using Terms

        return result


class WolframBeta:
    def __init__(self, input_path, output_path):
        """
        :param input_path: path of input query file
        :param output_path: path of output file storing result
                            generated by wolfram beta
        """
        self.input_path = input_path
        self.output_path = output_path

        # if you need more initializing process,
        # just write your code !

        pass

    @staticmethod
    def d_dx(equation):
        """
        :param equation: str
        :return: equation str (differential result)
        """
        # using Terms's class function
        return str()  # equation

    @staticmethod
    def integral(equation, constant):
        """
        :param equation: str
        :param constant: str
        :return: str equation (integral result)
        """
        # using Terms's class function
        return str()  # equation

    @staticmethod
    def compute(equation, x):
        """
        :param equation: str
        :param x: str
        :return: str <- not int type
        """
        # using Terms's class function
        return str()  # result

    def solve_query(self, line):
        """
        :param line: str (query)
        :return: str (result)
        """
        try:
            # 이 안에 코드를 작성해주세요!
            # solve_query() 함수에서 실행 도중 불가피한 오류가 발생하더라도,
            # 다음 쿼리를 받아들일 수 있게 도와줍니다.
            return ''  # if line == 'D,x^2'
        except:
            traceback.print_exc()
            return ''

    def solve(self):
        """
        :return: None (파일 입출력으로 문제 해결)
        """
        return


if __name__ == '__main__':
    ipath = 'input_sample.txt'
    opath = 'output_sample.txt'

    wolfram_beta = WolframBeta(ipath, opath)
    wolfram_beta.solve()